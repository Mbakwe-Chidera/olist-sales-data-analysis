#!/usr/bin/env python
# coding: utf-8

# In[1]:


import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

get_ipython().run_line_magic('matplotlib', 'inline')


# In[2]:


#load datasets into a dataFrame

customers = pd.read_csv(r'C:\Users\Mbder\Downloads\New Folder\olist_customers_dataset.csv')
location = pd.read_csv(r'C:\Users\Mbder\Downloads\New Folder\olist_geolocation_dataset.csv')
order_items = pd.read_csv(r'C:\Users\Mbder\Downloads\New Folder\olist_order_items_dataset.csv')
order_payments = pd.read_csv(r'C:\Users\Mbder\Downloads\New Folder\olist_order_payments_dataset.csv')
order_reviews = pd.read_csv(r'C:\Users\Mbder\Downloads\New Folder\olist_order_reviews_dataset.csv')
orders = pd.read_csv(r'C:\Users\Mbder\Downloads\New Folder\olist_orders_dataset.csv')
products = pd.read_csv(r'C:\Users\Mbder\Downloads\New Folder\olist_products_dataset.csv')
sellers = pd.read_csv(r'C:\Users\Mbder\Downloads\New Folder\olist_sellers_dataset.csv')
translation = pd.read_csv(r'C:\Users\Mbder\Downloads\New Folder\product_category_name_translation.csv')


# 1. Customers

# In[3]:


customers.head()


# 2. GeoLocation

# In[4]:


location.head()


# 3. Order Items

# In[5]:


order_items.head()


# 4. Order Payments

# In[6]:


order_payments.head()


# 5. Order Review

# In[7]:


order_reviews.head()


# 6. Orders

# In[8]:


orders.head()


# 7. Product

# In[9]:


products.head()


# 8. Sellers

# In[10]:


sellers.head()


# 9. Translation

# In[97]:


translation.head()


# ## 1. What is the total revenue generated by Olist, and how has it changed over time?
# This is the total money generated from sales of products on the olist e-commerce platform

# In[129]:


#clean orders dataframe first
#data cleaning of orders dataframe


# In[13]:


#1.remove the timestamp by creating new column with only date showing
orders['orders_date'] = orders['order_purchase_timestamp'].apply(lambda x: x[0:10])

# 2. Change the new date column to datetime datatype
orders['orders_date'] = pd.to_datetime(orders['orders_date'])

# 3. Create a new dataframe, with only the needed columns
orders2 = orders.drop(['order_purchase_timestamp','order_approved_at','order_delivered_carrier_date',
                             'order_delivered_customer_date','order_estimated_delivery_date'], axis = 1)
# show the result
orders2.head()


# In[14]:


order_payments.head()


# In[68]:


# Merge the two dataframes on the "order_id" column
merged_order_and_orderpayment = pd.merge(orders, order_payments, on='order_id')

# Select the desired columns
merged_order_and_orderpayment = merged_order_and_orderpayment[['order_id', 'customer_id', 'order_status', 'orders_date',
                            'payment_sequential', 'payment_type', 'payment_installments', 'payment_value']]

# Print the first 10 rows of the merged dataframe
merged_data.head()


# Clean Joined DataFrame

# In[16]:


# Drop canceled and unavailable order_status rows

merged_data.drop(merged_data[merged_data['order_status'] == 'canceled'].index, axis=0, inplace = True)

merged_data.drop(merged_data[merged_data['order_status'] == 'unavailable'].index, axis=0, inplace = True)


# a) Find the total revenue

# In[17]:


Total_Revenue = merged_data['payment_value'].sum()
Total_Revenue_Millions = round(Total_Revenue/1000000,2)

print('The total revenue generated by Olist is R${}M'.format(Total_Revenue_Millions))


# b) Find the trend of revenue overtime

# In[18]:


# Create a quartely time period for the payment value

#1. create a new dataframe with only the orders date and payment value columns 
revenue_trend = merged_data.loc[:,['orders_date', 'payment_value']]

#2. set the order_purchase_date as the index of the dataframe
revenue_trend = revenue_trend.set_index('orders_date')

#3. Group the order_puchase_date by quarter and find the sum of payment value for each quarter
quarter_total_revenue = revenue_trend.resample('Q', closed='right').agg({'payment_value': 'sum'})

# Show result
quarter_total_revenue


# In[19]:


# Create a line plot to show the trend of revenue overtime

fig,ax = plt.subplots(figsize = (10,4))

quarter_total_revenue.plot(ax = ax, legend = False)

plt.xlabel('Yearly Quarter')
plt.ylabel('Total Revenue')
plt.title("Line plot showing the trend of revenue for each year's quarter")
plt.show()


# This chart shows the total payment value for orders made on a quarterly basis and is grouped by order_purchase_date, which is the date when the orders were made.
# 
# According to the chart, the highest total payment value was recorded in the second quarter of 2018 (i.e., the period between April and June 2018), with a total payment value of 3,322,546.83. This was closely followed by the total payment value recorded in the first quarter of 2018 (i.e., the period between January and March 2018), with a total payment value of 3,235,342.38. The lowest total payment value was recorded in the third quarter of 2016 (i.e., the period between July and September 2018), with a total payment value of 136.23. Overall, it appears that the total payment value increased from September 2016 to June 2018, before decreasing in the following quarters.
# 
# The chart provides insight into the amount of revenue generated by orders made on a quarterly basis, which can be useful for identifying trends and patterns in the company's sales performance over time.

# # 2. How many orders were placed on Olist, and how does this vary by month?

# Using the cleaned orders dataframe

# In[20]:


# Drop rows with order status that shows canceled and unavailable
orders2 = orders2.drop(orders2[orders2['order_status'] == 'canceled'].index, axis=0)

orders2  = orders2.drop(orders2[orders2['order_status'] == 'unavailable'].index, axis=0)
orders2.head()


# Answering the business question

# # a) The total number of orders placed on Olist

# In[21]:


num_of_orders = len(orders2['order_id'].unique())

print('The total number of orders placed on Olist is {}'.format(num_of_orders))


# b) Find the trend of orders placed monthly

# In[22]:


# Create a monthly time period for orders placed

#1. create a new dataframe with only the order_id columns and order purchase date
placed_orders_trend = orders2.loc[:,['order_id', 'orders_date']]

#2. set the order_purchase_date as the index of the dataframe
placed_orders_trend = placed_orders_trend.set_index('orders_date')

#3. Rename the column of the dataframe
placed_orders_trend = placed_orders_trend.rename(columns = {'order_id' : 'order_id_count'})

#4. Group the order_puchase_date by quarter and find the count of each quarter
monthly_order_placed = placed_orders_trend.resample('M').agg({'order_id_count': 'count'})

# Show result
monthly_order_placed


# In[23]:


# Create a line plot to show the trend of orders placed monthly

fig,ax = plt.subplots(figsize = (10,4))

monthly_order_placed.plot(ax = ax, legend = False)

plt.xlabel('Month')
plt.ylabel('Total Orders Placed')
plt.title("Line plot showing the orders trends placed each month")
plt.show()


# The chart represents the count of number of orders made each month from September 2016 to September 2018. The data shows a fluctuating trend with an initial count of 2 orders in September 2016 and a peak of 7423 orders in November 2017. The number of orders then decreases in December 2017 and rises again to 7187 in January 2018, followed by a gradual decrease until September 2018, where the number of order reaches one.
# 
# This information can be used to help identify trends and make informed business decisions, such as planning inventory and staffing levels for peak months.

# # 3. What are the most popular product categories on Olist, and how do their sales volumes compare to each other?

# In[24]:


#merge 3 (products, translation, order_items) dataframes


# In[98]:


merge_2 = pd.merge(products, order_items, on='product_id')


# In[100]:


merged_product = pd.merge(merge_2, translation, on='product_category_name')


# In[103]:


merged_product.head()


# Group the column needed for this analysis and show its value count

# In[28]:


# Group the product_category_name_english by its categories and find the count of each category
grouped_product_category = merged_product.groupby('product_category_name_english')['product_category_name_english'].count().sort_values(ascending = False)

# Convert it to a Dataframe
grouped_product_category = pd.DataFrame(grouped_product_category)

# Rename the count column
grouped_product_category = grouped_product_category.rename(columns = {'product_category_name_english':'product_count'})

# Show the result
grouped_product_category


# Answering business questions

# In[29]:


#Draw the bar plot for the above table

# Select top 10 categories
top10_product_category = grouped_product_category.head(10)

# Set the axis
fig,ax = plt.subplots(figsize = (10,4))

# plot the barplot using plt and have the values in the x axis
top10_product_category.sort_values(by = 'product_count').plot(ax = ax, kind = 'barh')

# Plot the bar chart using seaorn
#sns.barplot(x = top10_product_category['product_count'] , y= top10_product_category.index )

plt.xlabel('Sales Volume')
plt.ylabel('Product Category')
plt.title("Bar Plot showing the top 10 popular product categories based on their sale volume")
plt.show()


# Bed Bath Table, Health Beauty, Sport Leisure, Furniture Decor, Computer Accessories, Housewares, Watches Gifts, Telephone, Garden Tools and Auto are the most popular product categories based on their sale volume.
# 
# However, Bed Bath Table accounts for the product with the highest sales volume, with 11,115 products sold between January 2017 and August 2018

# # 4. What is the average order value (AOV) on Olist, and how does this vary by product category and payment method?
# a) What is the average order value (AOV) on Olist?

# In[30]:


Total_Revenue = merged_data['payment_value'].mean()
Total_Revenue = round(Total_Revenue,2)
print('The average order value is R${}'.format(Total_Revenue))


# b) How does this value vary by payment method

# In[31]:


merged_data.head()


# In[32]:


# Group the payment type by its categories and find the mean of payment value for each category.
# sort_values(ascending = False) orders the result in descending order
# reset_index convertes the result to a dataframe 
# name ='mean_payment_value' renames the new column created 
average_order_per_paymentmethod = merged_data.groupby('payment_type')['payment_value'].mean().sort_values(ascending = False).reset_index(name = 'mean_payment_value')

# Set payment_type column  as my index
average_order_per_paymentmethod.set_index('payment_type', inplace=True)

# Show the result
average_order_per_paymentmethod


# In[33]:


# Draw the bar plot for the above table

# Set the axis
fig, ax = plt.subplots(figsize = (10,4))

# Plot the bar
average_order_per_paymentmethod.plot.bar(ax = ax, legend = False)

plt.xlabel('Product Type')
plt.ylabel('Average Payment Value')
plt.title("Bar Plot showing average payment value for each payment type")
plt.show()


# The graph above indicated that credit_card has the highest average payment value, followed by boleto with voucher being the least

# # c) How does this value vary by product category
# To answer this question, we need the products, translation, and order_items joined dataset

# In[34]:


# Create a new column that sums price and frieght vale to get the payment value
merged_product['payment_value'] = merged_product['price'] + merged_product['freight_value']

# Group the product_category_name_english by its categories and find the average payment value for each category
average_order_per_productcategory = merged_product.groupby('product_category_name_english')['payment_value'].mean().sort_values(ascending = False).reset_index(name = 'mean_payment_value')

# Set product_category_name_english column  as my index
average_order_per_productcategory.set_index('product_category_name_english', inplace=True)

# Show the result
average_order_per_productcategory 


# In[35]:


# Draw the bar plot for the above table

# Select top 10 categories
top10_average_order_per_productcategory = average_order_per_productcategory.head(10)

# Set the axis
fig,ax = plt.subplots(figsize = (10,4))

# plot the barplot using plt and have the values in the x axis
top10_average_order_per_productcategory.sort_values(by = 'mean_payment_value').plot(ax = ax, kind = 'barh', legend = False)

plt.xlabel('Average Payment Value')
plt.ylabel('Product Category')
plt.title("Bar Plot showing the top 10 popular product categories based on average payment value")

plt.show()


# Computers, Small appliances home oven and coffee, home appliances2, agro industry and commerce, musical instruments, small appliances, fixed telephone, construction toold safety, furniture bedroom and watches gift are the highest product categories based on the average payment value.
# 
# However, Computers have the overall highest average payment value with a value of 1146.79 Brazilain Real

# # 5. How many active sellers are on olist?

# In[36]:


order_items.head(10)


# In[37]:


# Group the sellers by seller id and find the count of order id for each seller id. 
active_sellers = order_items.groupby('seller_id')['order_id'].count().sort_values(ascending = False).reset_index(name = 'order_count_per_seller_id')

#Set seller_id column as index
active_sellers .set_index('seller_id', inplace = True)

# Show the result
active_sellers.head(10)


# The table above shows the top 10 active sellers on Olist.

# # 6. What is the distribution of seller ratings on Olist, and how does this impact sales performance?
# To answer this question we will need to merge order_items and order_reviews dataFrame

# In[131]:


merged_order_and_product = pd.merge(order_items, order_reviews, on='order_id')
merged_order_and_product


# In[132]:


# Drop columns with null values and repeeated columns
merged_order_and_product.drop(['review_comment_title','review_comment_message'], axis = 1, inplace = True)


# # a). What is the distribution of sellers rating on Olist

# In[40]:


# Group the column needed for this analysis and show their value count

# Group the seller_id column by each individual seller and find the average review score for each seller,
# then round it to a whole number
sellerid_reveiwscore_mean = round(merged_order_and_product.groupby('seller_id')['review_score'].mean(),0).reset_index()

# Show the result
sellerid_reveiwscore_mean


# In[41]:


# Group the review score column by its ratings and find the number of sellers placed under each rating 
grouped_reviewscore_bysellers  = merged_order_and_product.groupby('review_score')['seller_id'].count().sort_values(ascending = False).reset_index(name = 'count')

# Set review_score as index
grouped_reviewscore_bysellers.set_index('review_score', inplace = True)

# Show the result
grouped_reviewscore_bysellers 


# In[42]:


# Draw the bar plot for the above table

# Set the axis
fig, ax = plt.subplots(figsize = (10,4))

# Plot the bar
grouped_reviewscore_bysellers.plot.bar(ax = ax, legend = False)

plt.xlabel('Review Score')
plt.ylabel('Number of sellers')
plt.title("Bar Plot showing the number of sellers that have a particular rating")
plt.show()


# Details from the graph shows more sellers recieved high rating of 4.0 and few recieved minimum rating of 2.0

# # b) How does each rating impact sales volume?

# In[43]:


# Group the review score column by its ratings and find number of orders that recieve each rating
grouped_reviewscore_byorders = merged_order_and_product.groupby('review_score')['order_id'].count().sort_values(ascending = False)

# Set the axis
fig, ax = plt.subplots(figsize = (10,4))

# Plot the bar
grouped_reviewscore_byorders.plot.bar()

plt.xlabel('Review Score')
plt.ylabel('Number of orders')
plt.title("Bar Plot showing the volume of orders for each rating")
plt.show()


# From the graph i obsevered that the higher the rating the higher the product orders, the lower the rating the lower the product order
# 

# 
# # 7. How many customers have made repeat purchases on Olist, and what percentage of total sales do they account for?

# In[44]:


customers.head()


# In order to get this answer, we will look through both customer_id and customer_unique_id columns of the customer_df dataframe to see if there are any repeating customers.

# In[45]:


print('This table contains {} rows'.format(customers.shape[0]))
print('There are {} unique customer_id'.format(len(customers['customer_id'].unique()))) 
print('There are {} unique customer_unique_id'.format(len(customers['customer_unique_id'].unique())))


# There are 96,069 customer_unique_id's out of 99,441 number of rows. This means that there are repeating cutomers found in this column
# 
# 

# In[46]:


number_of_uniquecustomers = customers['customer_unique_id'].value_counts()
number_of_uniquecustomers = number_of_uniquecustomers[number_of_uniquecustomers > 1]
num_of_repeating_customers = len(number_of_uniquecustomers)
print('There are {} repeating customers'.format(num_of_repeating_customers))


# In[47]:


num_of_onetime_customers = len(customers['customer_unique_id'].unique()) - num_of_repeating_customers
print('There are {} one time customers'.format(num_of_onetime_customers))


# In[56]:


# set desired colors
colors = ['black', 'blue']

# create a pie chart showing the number of repeating and one time customers
plt.pie([num_of_repeating_customers, num_of_onetime_customers] , labels = ['Repeating Customer', 'Onetime_customers'], colors = colors)

# set the title and axis labels
plt.title('Customer Distribution')

# show the plot
plt.show();


# # b) What percentage of total sales do the repeating customers account for?
# The customers,orders and order_items will be merged

# In[133]:


customer_orders = pd.merge(customers, orders, on='customer_id')


# In[134]:


customer_orders2 = pd.merge(customer_orders, order_items, on='order_id')
customer_orders2


# In[135]:


# Drop unnecessary rowcusomer_orders_orderitems_joined_df.drop(cusomer_orders_orderitems_joined_df[cusomer_orders_orderitems_joined_df['order_status'] == 'canceled'].index, axis=0, inplace = True)
customer_orders2.drop(customer_orders2[customer_orders2['order_status'] == 'canceled'].index, axis=0, inplace = True)
customer_orders2.drop(customer_orders2[customer_orders2['order_status'] == 'unavailable'].index, axis=0, inplace = True)


# Answering business questions

# In[137]:


# Group orders by customer_unique_id and count the number of orders for each customer
orders_per_customer = customer_orders2.groupby('customer_unique_id')['order_id'].count()

# Filter customers with more than one order and sum up their sales
repeating_customers = orders_per_customer[orders_per_customer > 1]

# Find the sum of the price for all customers that have placed more than 1 order
total_price = customer_orders2[customer_orders2['customer_unique_id'].isin(repeating_customers.index)].groupby('customer_unique_id')['price'].sum().sum()

# Find the sum of the freight value for all customers that have placed more than 1 order
total_freight_value = customer_orders2[customer_orders2['customer_unique_id'].isin(repeating_customers.index)].groupby('customer_unique_id')['freight_value'].sum().sum()

#Find the sum of both price and freight value
total_sales = total_price + total_freight_value

# Total revenue was answered in the very first question
Total_Revenue

# Find the percentage of total sales made by repeating customer is
repeating_customers_percentage = round((total_sales/Total_Revenue)*100)

print('The percentage of total sales made by repeating customer is {}%'.format(repeating_customers_percentage))


# # 8. What is the average customer rating for products sold on Olist, and how does this impact sales performance?

# In[61]:


order_reviews.head()


# In[62]:


average_order_review_ratings = round(order_reviews['review_score'].mean(),0)
print('The average customer rating for all orders on olist is {}'.format(average_order_review_ratings))


# # 9. What is the total order cancellation on Olist, and how does this impact the company's revenue?
# a) What is the total order cancellation on Olist?
# We will use the orders dataframe to filter and check how many orders were canceled and unavailable.

# In[63]:


orders.head()


# In[64]:


# Filter the dataframe to show only rows with canceled and unavailable order status and find the how many rows are present
total_canceled_orders = len(orders[(orders['order_status'] == 'canceled') | (orders['order_status'] == 'unavailable')])

print('The total number of canceled orders on olist is {}'.format(total_canceled_orders))


# ## b) How does this impact the company's revenue
# We will use the orders and order_payment merged dataframe to see how much the company lost due to canceled orders.

# In[69]:


merged_order_and_orderpayment.head()


# In[71]:


# Filter the dataframe to show only rows with canceled and unavailable order status and find the sum of the payment values for these rows
canceled_order_amount =merged_order_and_orderpayment[(merged_order_and_orderpayment['order_status'] == 'canceled') | (merged_order_and_orderpayment['order_status'] == 'unavailable')]['payment_value'].sum()
canceled_order_amount = round(canceled_order_amount,0)

# Find the percentage loss due to canceled orders
all_revenue = merged_order_and_orderpayment['payment_value'].sum()
percentage_loss = round((canceled_order_amount/all_revenue)*100,2)


print('The canceled orders on olist lost the company R${}'.format(canceled_order_amount))
print("The company lost {}% of it's revenue due to canceled orders".format(percentage_loss))


# ## 10. Which payment methods are most commonly used by Olist customers
# To answer this question, we will need to merge 3 dataframes, customers, orders and order_payments

# In[82]:


customer_orders_payment = pd.merge(customer_orders2, order_payments, on='order_id')
customer_orders_payment


# In[83]:


# Group the payment type by its categories and count the number in each category
payment_methods = customer_orders_payment.groupby('payment_type')['payment_type'].count().sort_values(ascending = False)
payment_methods


# In[84]:


# Draw a bar plot for the table above

fig, ax = plt.subplots(figsize = (10,4))

payment_methods.plot.bar()

plt.xlabel('Payment Method')
plt.ylabel('Number of customer users')
plt.title('Bar plot showing the frequency of payment methods used for orders')

plt.show()


# it is shown that large number of customers that shop on Olist use credit cards to make payments and a very few number of customers use debit cards.
# 
# 

# ## 11. Which product categories have the highest revenue on Olist, and how can the company increase revenue across different categories?
# We will use product_productcategory_orderitems_df to answer this question.

# In[105]:


product_item_translation = pd.merge(products, translation, on='product_category_name')
product_item_translation


# In[120]:


product_order_items = pd.merge(merged_data, merged_product, on='order_id')
product_order_items.head()


# In[116]:


# Create a new dataframe using only the required columns from product_productcategory_orderitems_df
product_category_price = product_order_items.loc[:,['product_category_name_english','payment_value']]
product_category_price.head()


# In[121]:


# Group the product_category_name_english column by its categories and find the sum of revenue for each category. 
# Use reset_index to convert it to a dataframe and name='total_revenue' to rename the new column
grouped_product_category = product_category_price.groupby('product_category_name_english')['payment_value'].sum().sort_values(ascending = False).reset_index(name = 'total_revenue')

# Set product_category_name_english as the index
grouped_product_category.set_index('product_category_name_english', inplace = True)

# Get the top 10 product categories that generate the highest revenue
top10_productcategories = grouped_product_category.head(10)

# Show the result
top10_productcategories 


# In[122]:


# Draw a bar plot for the table above

fig, ax = plt.subplots(figsize = (10,4))

top10_productcategories.sort_values(by = 'total_revenue').plot(ax = ax, kind = 'barh', legend = False)

plt.xlabel('Total Revenue')
plt.ylabel('Product Categories')
plt.title('Bar plot showing the total revenue for each top 10 product categories')

plt.show()


# The product categories that generated the highest revenue are bed_bath_table, health_beauty, computers_accessories, furniture_decor, watches_gifts, sports_leisure, housewares, auto, garden_tools and cool_stuff.
# 
# Some strategies the company can adopt to increase revenue acress other product categories include:
# 
# Analyzing and segmenting customers: The company can analyze their customer base to identify different customer segments with specific needs and preferences. By developing targeted marketing and sales strategies for each segment, the company can increase revenue by offering personalized products and services that meet their specific needs.
# 
# Offering promotions and discounts: Promotions and discounts can be used to attract new customers and increase sales volume. Companies can offer limited-time promotions, bundle deals, or loyalty programs to encourage customers to purchase more products.
# 
# Developing new products: Developing new products can help the company expand their product offerings and increase revenue. This could involve launching new products in existing categories or exploring new product categories altogether.
# 
# Improving pricing strategy: By analyzing market trends and customer behavior, the company can adjust their pricing strategy to increase revenue. This could involve raising prices for high-demand products or lowering prices for less popular products to stimulate demand.

# ## 12. What Geolocation has high customer density.
# We will use the customer_orders_payment joined dataframe
# 
# 

# In[125]:


# Create a new dataframe using only the required columns from customer_orders_orderpayments_df
geolocation_order =  customer_orders_payment.loc[:,['customer_state','order_id', 'payment_value']]
geolocation_order.head()


# In[127]:


# Group the customer state by its categories and find the count of each category
geolocation_order_grouped = geolocation_order.groupby('customer_state')['order_id'].count().sort_values(ascending = False).reset_index(name = 'count')

# Set customer state as the index
geolocation_order_grouped.set_index('customer_state',inplace = True)

# Show the result
geolocation_order_grouped


# In[128]:


# Draw the bar plot using the above table

fig, ax = plt.subplots(figsize = (10,4))

geolocation_order_grouped.plot.bar(ax = ax, legend = False)

plt.xlabel('Customer State')
plt.ylabel('Number of orders')
plt.title('Bar plot showing the number of orders for each state')

plt.show()


# Brief Analysis and Insight
# 
# This analysis included the months of September 2016 through September 2018. Throughout this time;
# 
# 
# Olist made 15.74 million Brazilian Reals in total income.
# 
# There were 98207 orders placed in total on Olist.
# 
# According to sales volume, the most popular product categories were Bed Bath & Table, Health & Beauty, Sport & Leisure, Furniture & Decor, Computer Accessories, Housewares, Watches & Gifts, Telephone, Garden Tools, and Auto.
# 
# The typical order was worth 153.44 Brazilian Reals.
# 
# Following boleto and debit card in order of greatest average payment value was credit card. The smallest average payment value was a voucher.
# 
# Computers, home oven, small appliances, coffee Agricultural industry and trade, Home Appliances 2, appliances, musical instruments, and a fixed phone, construction warned about safety furniture for bedrooms
# 2033, 1987, 1931, 1775, 1551, 1499, 1428, 1364, 1203, and 1171 product orders were received from the top 10 active vendors on Olist, accordingly.
# 
# 
# For their products or services, most sellers obtained an average rating of 4.0. Only a few sellers were given a (1.0 and 2.0) low rating.
# Large orders were placed for the products with the highest ratings (5 and 4), whereas fewer orders were placed for the products with lower ratings.
# 
# Out of 96,069 total clients, 2997 returned customers represented 20% of the total purchases.
# 
# For all orders on olist, the overall average customer rating was 4.0.
# 
# 1234 orders were canceled in total on olist, costing the business 269,735 Brazillian Real, or 1.68% of its overall income.
# 
# Customers who made purchases on Olist tended to pay with credit cards rather than debit cards in big numbers.
# 
# Bed_bath_table, health_beauty, computers_accessories, furniture_decor, watches_gifts, sports_leisure, housewares, auto, garden_tools and cool_stuff. Tools were the product categories that brought in the most money for the business.
# 
# The state with the most orders was SP, which recorded a total of 49,566; the state with the fewest orders, RR, recorded a total of 52.

# ## Solutions that have been suggested to boost the performance of the business
# Here are some steps Olist could take to increase its income and profit in light of the above observations.
# 
# Increase marketing efforts: According to the data, it would seem that Olist makes more money from selling products in the Health & Beauty, Watches & Gifts, and Bed Bath & Table categories. Sales and revenue may rise if marketing strategies were focused on promoting these areas.
# 
# Recurring customers should receive rewards because they represent a sizeable amount of Olist's sales (about 20%). By providing incentives like discounts, loyalty programs, or exclusive access to new products, Olist may be able to retain customers and boost sales.
# 
# Increase seller ratings: Buyers frequently choose merchants with better ratings. Sales and revenue may rise if vendors with poor ratings are encouraged to raise them through improved customer service, more accurate product descriptions, and prompt shipping.
# 
# Increase payment alternatives: Although credit cards are the most widely used payment method, adding new payment options, such e-wallets, could draw more customers and boost sales.
# 
# Enhance your product choices: According to the research, Olist earns more money from some product categories. More product options within these categories and the provision of rare or hard-to-find items might draw more clients and boost sales. Adding exclusive or niche brands to Olist's present restricted assortment of health and beauty products, for instance, can help the company stand out in the market and draw in new clients who are searching for those particular products.
# 
# Reduce order cancellations as much as possible because they cost businesses money and undermine consumer confidence. Implementing strategies like better customer service and inventory management could decrease order cancellations and boost sales.
# 
# 

# In[ ]:




